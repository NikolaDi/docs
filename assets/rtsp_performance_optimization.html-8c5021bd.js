import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as r,c as l,a as e,d as a,b as i,e as c}from"./app-5e987558.js";const o={},d=e("h2",{id:"概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#概述","aria-hidden":"true"},"#"),a(" 概述")],-1),h={href:"https://github.com/xiongziliang/ZLMediaKit/commit/b169f94cce1ecbab50248f25ee3b33dd40602fe1",target:"_blank",rel:"noopener noreferrer"},u=e("ul",null,[e("li",null,[e("strong",null,"缓存时间戳相同的RTP包(意味着是同一帧数据)，作为一个数据包进行分发"),a("。")])],-1),g=e("p",null,[a("理论上，这样做可以大大"),e("strong",null,"减少多线程分发时线程切换次数、多余发送逻辑代码的执行以及系统调用次数"),a("，预期在不增加播放延时的情况下能大幅提高rtsp服务器的性能.")],-1),p=e("h2",{id:"测试",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#测试","aria-hidden":"true"},"#"),a(" 测试")],-1),b=e("p",null,"为了验证本次优化的预期目标，我在linux服务器上做了一系列的测试对比，以下是测试环境：",-1),m=e("li",null,"操作系统：ubuntu16 desktop 64bit",-1),_=e("li",null,"cpu： 4核心的Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz",-1),f=e("li",null,"编译器：gcc 5.4.0，开启Release编译(cmake -DCMAKE_BUILD_TYPE=Release)",-1),x=e("li",null,"malloc库：连接jemalloc",-1),z=e("li",null,"网络： 127.0.0.1本地循环网络",-1),y={href:"https://github.com/xiongziliang/ZLMediaKit/blob/master/tests/test_benchmark.cpp",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/xiongziliang/ZLMediaKit/tree/master/server",target:"_blank",rel:"noopener noreferrer"},k=e("li",null,"测试码流：4K H264的RTSP流，通过MP4 Rtsp点播实现，文件200秒，190MB,码流大概8Mb/s",-1),K=e("li",null,"测试方法：通过test_benchmark播放500路RTSP 4K点播，总码流大概4Gb/s，分别测试新老版本的MediaServer的进程。",-1),L=c('<h2 id="测试数据" tabindex="-1"><a class="header-anchor" href="#测试数据" aria-hidden="true">#</a> 测试数据</h2><ul><li>启动的播放器个数：<br><img src="https://user-images.githubusercontent.com/11495632/78686734-f6d31180-7925-11ea-9ba3-864865a910b9.png" alt="image" loading="lazy"></li><li>实时码流:<br><img src="https://user-images.githubusercontent.com/11495632/78686849-1b2eee00-7926-11ea-9434-a4f943021be5.png" alt="image" loading="lazy"></li></ul><h2 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比" aria-hidden="true">#</a> 性能对比</h2><h3 id="老版本数据" tabindex="-1"><a class="header-anchor" href="#老版本数据" aria-hidden="true">#</a> 老版本数据</h3><ul><li><p>cpu使用率(浮动比较大，最高200%+)：<br><img src="https://user-images.githubusercontent.com/11495632/78687097-621ce380-7926-11ea-9adb-80ccbbfca1f3.png" alt="image" loading="lazy"><br><img src="https://user-images.githubusercontent.com/11495632/78687391-b031e700-7926-11ea-9b81-0339d8d9dafd.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：<br><img src="https://user-images.githubusercontent.com/11495632/78687480-c8096b00-7926-11ea-9d72-f21fffa8fd7d.png" alt="image" loading="lazy"></p></li><li><p>总结 ： cpu占用主要发生在内核态的系统调用(syscall)、tcp_sendmsg、内存拷贝。</p></li></ul><h3 id="新版本数据" tabindex="-1"><a class="header-anchor" href="#新版本数据" aria-hidden="true">#</a> 新版本数据：</h3><ul><li><p>cpu使用率(浮动比较小，50%以下)：<br><img src="https://user-images.githubusercontent.com/11495632/78688226-9e9d0f00-7927-11ea-8d31-49d487f339b4.png" alt="image" loading="lazy"><br><img src="https://user-images.githubusercontent.com/11495632/78687893-3b12e180-7927-11ea-9e41-653b771405de.png" alt="image" loading="lazy"></p></li><li><p>后面我又测试了2000个播放器，掉了一批，最后稳定在1800个左右，实时流量17.5Gb/s(单向)左右,cpu占用300%左右:<br><img src="https://user-images.githubusercontent.com/11495632/78741558-39c7d000-798c-11ea-9860-6dc18db1ef0c.png" alt="image" loading="lazy"><br><img src="https://user-images.githubusercontent.com/11495632/78741649-78f62100-798c-11ea-85a9-1810bf1deaf1.png" alt="image" loading="lazy"><br><img src="https://user-images.githubusercontent.com/11495632/78741678-8d3a1e00-798c-11ea-9aec-dff834620781.png" alt="image" loading="lazy"><br><img src="https://user-images.githubusercontent.com/11495632/78741720-ad69dd00-798c-11ea-83c6-1b0b57d79ba2.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：<br><img src="https://user-images.githubusercontent.com/11495632/78688104-7a413280-7927-11ea-953b-d3b9a4c5ed0c.png" alt="image" loading="lazy"></p></li><li><p>总结 ： cpu占用主要发生在内核态内存拷贝，系统调用(syscall)、tcp_sendmsg的开销很小。</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本次性能测试基本证明了预想，性能提升大概有4倍以上。<br> 本机器为i7-4790 4核心8线程的，所以cpu占用率最高为800%，现在ZLMediaKit在上面支撑500个4K RTSP播放器，实时流量大概4Gb/s时cpu使用率50%不到,通过简单换算，该cpu可以支撑大概8000个4K RTSP播放器，实时流量最高能达到64Gb/s，考虑到性能折损，我们保守估计可以支持6000个4K RTSP播放器，50Gb/s的流量。</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h2><p>在ZLMediaKit流媒体服务器中，通过智能指针引用计数的方式实现了多线程的数据分发，不管分发多少次，数据拷贝次数都是固定的，所以ZLMediaKit可以达到如此夸张的性能参数，但是在测试中，我们也能发现，性能占用已经大部分发生在内核态了，应用层的cpu占用反而不是瓶颈了。这是因为在内核态，写socket缓存需要做内存拷贝，随着播放器个数的增加，内存拷贝会越来越多，此时性能瓶颈不再是应用层，而是由于内存带宽瓶颈导致的内核性能瓶颈。</p>',11);function R(P,T){const t=n("ExternalLinkIcon");return r(),l("div",null,[d,e("p",null,[a("在最近ZLMediaKit的一次提交中，我对rtsp服务器的性能做了一次"),e("a",h,[a("改进"),i(t)]),a(",本次改进中，核心的思想是：")]),u,g,p,b,e("ul",null,[m,_,f,x,z,e("li",null,[a("测试客户端："),e("a",y,[a("test_benchmark"),i(t)])]),e("li",null,[a("测试服务器："),e("a",M,[a("MediaServer"),i(t)])]),k,K]),L])}const v=s(o,[["render",R],["__file","rtsp_performance_optimization.html.vue"]]);export{v as default};
